<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Feature Descriptors · ChemistryFeaturization.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://chemellia.github.io/ChemistryFeaturization.jl/stable/types/feature_descriptors/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ChemistryFeaturization.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><span class="tocitem">Types</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../abstracttypes/">Abstract Types</a></li><li><a class="tocitem" href="../atoms/">Atoms Objects</a></li><li class="is-active"><a class="tocitem" href>Feature Descriptors</a><ul class="internal"><li><a class="tocitem" href="#Hierarchy"><span>Hierarchy</span></a></li><li><a class="tocitem" href="#Functionality-common-to-all-feature-descriptors"><span>Functionality common to all feature descriptors</span></a></li><li><a class="tocitem" href="#Atom-Feature-Descriptors"><span>Atom Feature Descriptors</span></a></li><li><a class="tocitem" href="#Pair-Feature-Descriptors"><span>Pair Feature Descriptors</span></a></li></ul></li><li><a class="tocitem" href="../codecs/">Codec</a></li><li><a class="tocitem" href="../featurizations/">Featurization</a></li><li><a class="tocitem" href="../featurizedatoms/">Featurized Atoms</a></li></ul></li><li><a class="tocitem" href="../../utils/">Utilities</a></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Types</a></li><li class="is-active"><a href>Feature Descriptors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Feature Descriptors</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Chemellia/ChemistryFeaturization.jl/blob/main/docs/src/types/feature_descriptors.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="fd"><a class="docs-heading-anchor" href="#fd">Feature Descriptors</a><a id="fd-1"></a><a class="docs-heading-anchor-permalink" href="#fd" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ChemistryFeaturization.FeatureDescriptor" href="#ChemistryFeaturization.FeatureDescriptor"><code>ChemistryFeaturization.FeatureDescriptor</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">FeatureDescriptor</code></pre><p>A feature, in this context, refers to a distinct attribute manifested by an atomic system. A FeatureDescriptor describes a feature/class of features - i.e., its name, possible values, etc.</p><p>A FeatureDescriptor does NOT store any actual instances of the value(s) of the feature it describes. Simply put, it can be understood to be &quot;features of a feature&quot;.</p><p>All FeatureDescriptors MUST also describe an encoding and decoding scheme. This can (and should) be easily done using a Codec.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Chemellia/ChemistryFeaturization.jl/blob/ef30f5fd727f4057118d667a2b6edef5e94362f5/src/features/features.jl#L1-L15">source</a></section></article><p>Feature descriptors store all necessary information to encode and decode feature values on various parts of an <a href="../atoms/#atoms">Atoms</a> object and appropriately combine them into a single form (vector, matrix, etc.), describing the value(s) of the feature for the entire object.</p><p>For example, if an <code>ElementFeatureDescriptor</code> encodes a vector for each atom in an object, they could be concatenated together into a matrix with a column for each atom to describe a structure.</p><p>Feature Descriptors must be designed with interoperability in mind. A <a href="#fd">FeatureDescriptor</a> object must work deterministically with different datasets.</p><h2 id="Hierarchy"><a class="docs-heading-anchor" href="#Hierarchy">Hierarchy</a><a id="Hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Hierarchy" title="Permalink"></a></h2><p>The type hierarchy of these objects is currently as follows.</p><pre><code class="language-text hljs">AbstractType.AbstractFeatureDescriptor
├─── AbstractAtomFeatureDescriptor
│    ├─── SpeciesFeatureDescriptor
│    └─── ElementFeatureDescriptor
│
├─── AbstractEnvironmentFeatureDescriptor
│    └─── OrbitalFieldMatrix
│
└─── AbstractPairFeatureDescriptor
     ├─── BondFeatureDescriptor
     └─── PairFeatureDescriptor</code></pre><p>More details on each of these types can be found below.<br/>More types (e.g. environment features) will be implemented in the future!</p><h2 id="Functionality-common-to-all-feature-descriptors"><a class="docs-heading-anchor" href="#Functionality-common-to-all-feature-descriptors">Functionality common to all feature descriptors</a><a id="Functionality-common-to-all-feature-descriptors-1"></a><a class="docs-heading-anchor-permalink" href="#Functionality-common-to-all-feature-descriptors" title="Permalink"></a></h2><ul><li>they should be callable on atoms objects and return encoded features</li><li>Similarly, <code>decode</code> should work...</li></ul><article class="docstring"><header><a class="docstring-binding" id="ChemistryFeaturization.decode-Tuple{ChemistryFeaturization.AbstractType.AbstractFeatureDescriptor, Any}" href="#ChemistryFeaturization.decode-Tuple{ChemistryFeaturization.AbstractType.AbstractFeatureDescriptor, Any}"><code>ChemistryFeaturization.decode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decode(fd::AbstractFeatureDescriptor, encoded_feature)</code></pre><p>Decode <code>encoded_feature</code> using the feature descriptor <code>fd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Chemellia/ChemistryFeaturization.jl/blob/ef30f5fd727f4057118d667a2b6edef5e94362f5/src/features/features.jl#L51-L54">source</a></section></article><ul><li>the function <code>encodable_elements</code> should be defined on all feature descriptors, as it will be used to verify that a feature can be encoded for every atom in a structure.</li></ul><h2 id="Atom-Feature-Descriptors"><a class="docs-heading-anchor" href="#Atom-Feature-Descriptors">Atom Feature Descriptors</a><a id="Atom-Feature-Descriptors-1"></a><a class="docs-heading-anchor-permalink" href="#Atom-Feature-Descriptors" title="Permalink"></a></h2><p>These types encode features for single atoms in a structure. The abstract parent type is <code>AtomFeatureDescriptor</code>.</p><h3 id="Element-Feature-Descriptors"><a class="docs-heading-anchor" href="#Element-Feature-Descriptors">Element Feature Descriptors</a><a id="Element-Feature-Descriptors-1"></a><a class="docs-heading-anchor-permalink" href="#Element-Feature-Descriptors" title="Permalink"></a></h3><p>An <code>ElementFeatureDescriptor</code>&#39;s encoded values are defined only by the elemental identity of an atom. Examples include atomic mass and block (s, p, d, or f) in the periodic table.</p><article class="docstring"><header><a class="docstring-binding" id="ChemistryFeaturization.FeatureDescriptor.ElementFeatureDescriptor" href="#ChemistryFeaturization.FeatureDescriptor.ElementFeatureDescriptor"><code>ChemistryFeaturization.FeatureDescriptor.ElementFeatureDescriptor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ElementFeatureDescriptor</code></pre><p>Describe features associated with individual atoms that depend only upon their elemental identity</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Name of the feature</li><li><code>encoder_decoder::AbstractCodec</code>: Codec defined which handles the feature&#39;s encoding and decoding logic</li><li><code>categorical::Bool</code>: flag for whether the feature is categorical or continuous-valued</li><li><code>lookup_table::DataFrame</code>: table containing values of feature for every encodable element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Chemellia/ChemistryFeaturization.jl/blob/ef30f5fd727f4057118d667a2b6edef5e94362f5/src/features/elementfeature.jl#L9-L19">source</a></section></article><p>In the example, below, we first show and then encode the value of the block of each atom in a hydrogen molecule. The result is two <code>hcat</code>ted vectors [1 0 0 0], indicating hydrogen is <em>s</em>-block.</p><pre><code class="language-julia hljs">H2 = AtomGraph([0. 1.; 1. 0.], [&quot;H&quot;, &quot;H&quot;])
block = ElementFeatureDescriptor(&quot;Block&quot;)
block(H2) # equivalent to get_value(block, H2)

# output
2-element Vector{String}:
 &quot;s&quot;
 &quot;s&quot;</code></pre><pre><code class="language-julia hljs">julia&gt; encode(block, H2)
4×2 Matrix{Float64}:
 1.0  1.0
 0.0  0.0
 0.0  0.0
 0.0  0.0</code></pre><p>Because they are defined only by the element, values for these features can be tabulated in a lookup table. Many commonly-desired element features are included in the <code>atom_data_df</code> DataFrame, but you can also define custom lookup tables for other features by utilizing the <code>lookup_table</code> keyword of the <code>ElementFeatureDescriptor</code> constructor.</p><h3 id="Species-Feature-Descriptor"><a class="docs-heading-anchor" href="#Species-Feature-Descriptor">Species Feature Descriptor</a><a id="Species-Feature-Descriptor-1"></a><a class="docs-heading-anchor-permalink" href="#Species-Feature-Descriptor" title="Permalink"></a></h3><p>A <code>SpeciesFeatureDescriptor</code>&#39;s encoded values depend on its local environment. Examples are an atom&#39;s formal oxidation state, or whether it is part of an aromatic ring.</p><article class="docstring"><header><a class="docstring-binding" id="ChemistryFeaturization.FeatureDescriptor.SpeciesFeatureDescriptor" href="#ChemistryFeaturization.FeatureDescriptor.SpeciesFeatureDescriptor"><code>ChemistryFeaturization.FeatureDescriptor.SpeciesFeatureDescriptor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpeciesFeatureDescriptor{A}</code></pre><p>A feature object that encodes features associated with individual atoms (collectively depicted by a representation of type <code>A</code>) that depend upon their local environment in some way (if your feature is defined only by elemental identity, you should use ElementFeatureDescriptor!)</p><p>Type parameter represents the structure representation(s) from which this feature descriptor is able to compute features.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: the name of the feature</li><li><code>compute_f</code>: function that takes in a structure of type <code>A</code> and returns values of this feature for every atom in the structure</li><li><code>encoder_decoder::AbstractCodec</code>: codec that encodes/decodes values of this feature</li><li><code>categorical::Bool</code>: flag for whether the feature is categorical or continuous-valued</li><li><code>encodable_elements::Vector{String}</code>: list of elements (by symbol) that can be encoded by this feature</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Chemellia/ChemistryFeaturization.jl/blob/ef30f5fd727f4057118d667a2b6edef5e94362f5/src/features/speciesfeature.jl#L7-L20">source</a></section></article><p>A variety of built-in options for computing features on <code>GraphMol</code> objects (see MolecularGraph.jl package) are included. These can be constructed from a string, like</p><pre><code class="language-julia hljs">julia&gt; sfd = SpeciesFeatureDescriptor(&quot;isaromatic&quot;)

SpeciesFeature isaromatic:
   categorical: true
   works on: GraphMol</code></pre><p>This feature will return a an array of bits representing whether each atom in a structure is part of an aromatic ring. For example...</p><pre><code class="language-julia hljs">using MolecularGraph
using ChemistryFeaturization.Codec

caffeine = smilestomol(&quot;CN1C=NC2=C1C(=O)N(C(=O)N2C)C&quot;)
ag = AtomGraph(caffeine)</code></pre><pre><code class="language-julia hljs">julia&gt; get_value(sfd, ag)
14-element BitVector:
 0
 1
 1
 1
 1
 1
 1
 0
 1
 1
 0
 1
 0
 0</code></pre><p>We can also build custom <code>SpeciesFeatureDescriptors</code> &quot;from scratch.&quot; For a simple example, let&#39;s suppose we want to encode graph-related features:</p><pre><code class="language-julia hljs">julia&gt; ag = AtomGraph(Float32.([0 1; 1 1]), [&quot;H&quot;, &quot;O&quot;]) # build a simple AtomGraph with a self loop</code></pre><pre><code class="language-julia hljs"># a function that will take in a graph and return the number of neighbors of each node
num_nbs = g -&gt; first.(length.(neighbors.(Ref(g), 1:nv(g))))
# we&#39;ll encode neighbors counts categorically in four bins
codec = OneHotOneCold(true, [1,2,3,4])
categorical = true
ee = [&quot;O&quot;,&quot;H&quot;]
# the type parameter should match the type parameter of the AtomGraph object
sfd = SpeciesFeatureDescriptor{SimpleWeightedGraph}(&quot;num_neighbors&quot;, num_nbs, codec, categorical, ee)</code></pre><pre><code class="language-julia hljs">julia&gt; get_value(sfd, ag)
2-element Vector{Int64}:
 1
 2</code></pre><h2 id="Pair-Feature-Descriptors"><a class="docs-heading-anchor" href="#Pair-Feature-Descriptors">Pair Feature Descriptors</a><a id="Pair-Feature-Descriptors-1"></a><a class="docs-heading-anchor-permalink" href="#Pair-Feature-Descriptors" title="Permalink"></a></h2><p>Pair feature descriptors encode features of pairs of atoms. The abstract parent type is <code>AbstractPairFeatureDescriptor</code>.</p><p>The concrete type <code>PairFeatureDescriptor</code> encodes information about any pair of atoms, such as the distance between them.</p><h3 id="Bond-Feature-Descriptors"><a class="docs-heading-anchor" href="#Bond-Feature-Descriptors">Bond Feature Descriptors</a><a id="Bond-Feature-Descriptors-1"></a><a class="docs-heading-anchor-permalink" href="#Bond-Feature-Descriptors" title="Permalink"></a></h3><p>Bond feature descriptors are defined only for two atoms that are bonded to each other. Currently, the API is only built out for <code>AbstractAtoms</code> objects that have been constructed from <code>GraphMol</code> objects (defined by the MolecularGraph package). Similar to <code>SpeciesFeatureDescriptor</code>s, there are convenience functions defined in an associated utils file, and we can easily construct one like so:</p><pre><code class="language-julia hljs">julia&gt; bfd = BondFeatureDescriptor(&quot;bondorder&quot;)
BondFeatureDescriptor{GraphMol, OneHotOneCold} bondorder:
   categorical: true
   works on: GraphMol</code></pre><p>When we retrieve the values, note that they are now formatted as a (symmetric) matrix, with the two indices referring to the indices of the two atoms. If the atoms aren&#39;t bonded, that entry will be <code>missing</code>.</p><pre><code class="language-julia hljs">julia&gt; ag = AtomGraph(smilestomol(&quot;c1ccncc1&quot;)) # pyridine
AtomGraph{GraphMol{SmilesAtom, SmilesBond}}  with 6 nodes, 6 edges
        atoms: [&quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;N&quot;, &quot;C&quot;, &quot;C&quot;]
julia&gt; get_value(bfd, ag)
6×6 Matrix{Union{Missing, Int64}}:
  missing  2          missing   missing   missing  1
 2          missing  1          missing   missing   missing
  missing  1          missing  2          missing   missing
  missing   missing  2          missing  1          missing
  missing   missing   missing  1          missing  2
 1          missing   missing   missing  2          missing</code></pre><p>And when we encode it, the default result is now a 3D matrix (one vector for each pair of atoms). If the value is <code>missing</code>, the third dimension will be filled with <code>missing</code>:</p><pre><code class="language-julia hljs">julia&gt; Array{Union{Missing,Int}}(encode(bfd, ag)) # cast to Int so printing looks nicer, you could leave this off but would just see trues and falses instead
6×6×3 Array{Union{Missing, Int64}, 3}:
[:, :, 1] =
  missing  0          missing   missing   missing  1
 0          missing  1          missing   missing   missing
  missing  1          missing  0          missing   missing
  missing   missing  0          missing  1          missing
  missing   missing   missing  1          missing  0
 1          missing   missing   missing  0          missing

[:, :, 2] =
  missing  1          missing   missing   missing  0
 1          missing  0          missing   missing   missing
  missing  0          missing  1          missing   missing
  missing   missing  1          missing  0          missing
  missing   missing   missing  0          missing  1
 0          missing   missing   missing  1          missing

[:, :, 3] =
  missing  0          missing   missing   missing  0
 0          missing  0          missing   missing   missing
  missing  0          missing  0          missing   missing
  missing   missing  0          missing  0          missing
  missing   missing   missing  0          missing  0
 0          missing   missing   missing  0          missing</code></pre><p>Some of the built-in bond features are boolean valued, and by default are direct encoded (since onehot doesn&#39;t really make sense when there are only two options). In this case, the encoded matrix is equal to the values:</p><pre><code class="language-julia hljs">julia&gt; bfd = BondFeatureDescriptor(&quot;isringbond&quot;)
BondFeatureDescriptor{GraphMol, DirectCodec} isringbond:
   categorical: true
   works on: GraphMol
julia&gt; get_value(bfd, ag)
6×6 Matrix{Union{Missing, Bool}}:
     missing  true             missing      missing      missing  true
 true             missing  true             missing      missing      missing
     missing  true             missing  true             missing      missing
     missing      missing  true             missing  true             missing
     missing      missing      missing  true             missing  true
 true             missing      missing      missing  true             missing
 julia&gt; encode(bfd, ag)
6×6 Matrix{Union{Missing, Int64}}:
  missing  1          missing   missing   missing  1
 1          missing  1          missing   missing   missing
  missing  1          missing  1          missing   missing
  missing   missing  1          missing  1          missing
  missing   missing   missing  1          missing  1
 1          missing   missing   missing  1          missing</code></pre><p>(pyridine is a ring molecule, so every bond is a ring bond)</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../atoms/">« Atoms Objects</a><a class="docs-footer-nextpage" href="../codecs/">Codec »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 9 December 2021 17:55">Thursday 9 December 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
