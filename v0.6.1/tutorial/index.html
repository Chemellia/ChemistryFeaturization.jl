<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · ChemistryFeaturization.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://chemellia.github.io/ChemistryFeaturization.jl/stable/tutorial/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ChemistryFeaturization.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../terminology/">Terminology</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Creating/reading-in-a-structure"><span>Creating/reading in a structure</span></a></li><li><a class="tocitem" href="#Building-feature-descriptors"><span>Building feature descriptors</span></a></li><li><a class="tocitem" href="#Building-a-featurization"><span>Building a featurization</span></a></li><li><a class="tocitem" href="#Featurizing-structures"><span>Featurizing structures</span></a></li><li><a class="tocitem" href="#Decoding-encoded-features"><span>Decoding encoded features</span></a></li></ul></li><li><span class="tocitem">Types</span><ul><li><a class="tocitem" href="../types/overview/">Overview</a></li><li><a class="tocitem" href="../types/abstracttypes/">Abstract Types</a></li><li><a class="tocitem" href="../types/atoms/">Atoms Objects</a></li><li><a class="tocitem" href="../types/feature_descriptors/">Feature Descriptors</a></li><li><a class="tocitem" href="../types/codecs/">Codec</a></li><li><a class="tocitem" href="../types/featurizations/">Featurization</a></li><li><a class="tocitem" href="../types/featurizedatoms/">Featurized Atoms</a></li></ul></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../changelog/">Changelog</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Chemellia/ChemistryFeaturization.jl/blob/main/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><ul><li><a href="#Tutorial">Tutorial</a></li><li class="no-marker"><ul><li><a href="#Creating/reading-in-a-structure">Creating/reading in a structure</a></li><li class="no-marker"><ul><li><a href="#Create-&quot;from-scratch&quot;">Create &quot;from scratch&quot;</a></li><li><a href="#Reading-from-file">Reading from file</a></li><li><a href="#Batch-processing">Batch processing</a></li></ul></li><li><a href="#Building-feature-descriptors">Building feature descriptors</a></li><li><a href="#Building-a-featurization">Building a featurization</a></li><li><a href="#Featurizing-structures">Featurizing structures</a></li><li><a href="#Decoding-encoded-features">Decoding encoded features</a></li></ul></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This tutorial is currently focused on <a href="../types/atoms/#ChemistryFeaturization.Atoms.AtomGraph"><code>AtomGraph</code></a> objects, featurized using <a href="../types/feature_descriptors/#ChemistryFeaturization.FeatureDescriptor.ElementFeatureDescriptor"><code>ElementFeatureDescriptor</code></a>s in a <a href="../types/featurizations/#ChemistryFeaturization.Featurization.GraphNodeFeaturization"><code>GraphNodeFeaturization</code></a>, because these are the functionalities that are currently fully built, but we anticipate expanding it as more things are finished!</p></div></div><h2 id="Creating/reading-in-a-structure"><a class="docs-heading-anchor" href="#Creating/reading-in-a-structure">Creating/reading in a structure</a><a id="Creating/reading-in-a-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Creating/reading-in-a-structure" title="Permalink"></a></h2><h3 id="Create-&quot;from-scratch&quot;"><a class="docs-heading-anchor" href="#Create-&quot;from-scratch&quot;">Create &quot;from scratch&quot;</a><a id="Create-&quot;from-scratch&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#Create-&quot;from-scratch&quot;" title="Permalink"></a></h3><p>We can build an <code>AtomGraph</code> &quot;manually,&quot; by specifying an adjacency matrix and directly building the graph from that. Here I&#39;ll build a fictitious graph that&#39;s just an equiweighted triangle of carbon atoms:</p><pre><code class="language-julia-repl hljs">julia&gt; adj_mat = Float32.([0 1 1; 1 0 1; 1 1 0]);

julia&gt; triangle_C = AtomGraph(adj_mat, [&quot;C&quot;, &quot;C&quot;, &quot;C&quot;])
AtomGraph{SimpleWeightedGraphs.SimpleWeightedGraph{Int64, Float32}}  with 3 nodes, 3 edges
	atoms: [&quot;C&quot;, &quot;C&quot;, &quot;C&quot;]</code></pre><p>If you&#39;re working in an IDE that supports graphics output, you can also call <code>visualize(triangle_C)</code> to see the &quot;ball-and-stick&quot; graph.</p><h3 id="Reading-from-file"><a class="docs-heading-anchor" href="#Reading-from-file">Reading from file</a><a id="Reading-from-file-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-from-file" title="Permalink"></a></h3><p>In a &quot;real&quot; application, you&#39;ll likely be reading structures from files such as .cif, .xyz, etc. Here, we&#39;ll read in the structure of WS&lt;sub&gt;2&lt;/sub&gt;, downloaded from the <a href="https://materialsproject.org">Materials Project</a>:</p><pre><code class="language-julia-repl hljs">julia&gt; WS2 = AtomGraph(&quot;mp-224.cif&quot;)
┌ Warning: Your cutoff radius is quite large relative to the size of your unit cell. This may cause issues with neighbor list generation, and will definitely cause a very dense graph. To avoid issues, I&#39;m setting it to be approximately equal to the smallest unit cell dimension.
└ @ ChemistryFeaturization.Utils.GraphBuilding ~/Chemellia/ChemistryFeaturization.jl/src/utils/graph_building.jl:174
AtomGraph{Crystal} mp-224 with 6 nodes, 6 edges
	atoms: [&quot;W&quot;, &quot;W&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;]
</code></pre><p>The graph is automatically assigned an <code>id</code> based on the filename it was read from, but you can pass a value to override this and name it something else.</p><p>If you visualize this graph as above, you&#39;ll notice that it has two disconnected components. This isn&#39;t too surprising if we look at the 3D structure of this compound: <img src="../files/mp-224.png" alt="WS2_structure"/> It&#39;s a two-dimensional material with two formula units per unit cell! Another way to see the disconnectedness of the graph is to index into the adjacency matrix in a particularly illustrative order:</p><pre><code class="language-julia-repl hljs">julia&gt; WS2.graph[[1,4,6,2,3,5]].weights
6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 12 stored entries:
  ⋅   1.0      1.0       ⋅    ⋅        ⋅
 1.0   ⋅       0.19762   ⋅    ⋅        ⋅
 1.0  0.19762   ⋅        ⋅    ⋅        ⋅
  ⋅    ⋅        ⋅        ⋅   1.0      1.0
  ⋅    ⋅        ⋅       1.0   ⋅       0.19762
  ⋅    ⋅        ⋅       1.0  0.19762   ⋅</code></pre><p>However, we have options in how we actually construct the graph. The default option is based on the scheme from <a href="https://github.com/txie-93/cgcnn">the original cgcnn.py implementation</a>, which essentially involves setting a maximum neighbor distance and a maximum number of neighbors. However, in contrast to that implementation, we construct weighted graphs (with the user having an ability to specify the weight decay function with separation distance; it defaults to inverse-square).</p><p>An arguably more physical way to construct neighbor lists and graphs is by doing a <a href="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi partition</a> of the atomic coordinates. In this scheme, the neighbor list of an atom is any atom with which its Voronoi polyhedron shares a face, and the edge weights can be determined using the areas of the faces. Let&#39;s try that with our WS&lt;sub&gt;2&lt;/sub&gt; structure...</p><pre><code class="language-julia-repl hljs">julia&gt; WS2_v = AtomGraph(joinpath(&quot;..&quot;, &quot;files&quot;, &quot;mp-224.cif&quot;), use_voronoi=true);

julia&gt; WS2_v.graph[[1,4,6,2,3,5]].weights
6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 22 stored entries:
 0.371678  0.970448   0.970448    ⋅         ⋅          ⋅ 
 0.970448  1.0        0.0231855   ⋅         ⋅         0.31894
 0.970448  0.0231855  1.0         ⋅        0.31894     ⋅ 
  ⋅         ⋅          ⋅         0.371678  0.970448   0.970448
  ⋅         ⋅         0.31894    0.970448  1.0        0.0231855
  ⋅        0.31894     ⋅         0.970448  0.0231855  1.0</code></pre><p>(You can, of course, also visualize this one in your IDE)</p><h3 id="Batch-processing"><a class="docs-heading-anchor" href="#Batch-processing">Batch processing</a><a id="Batch-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-processing" title="Permalink"></a></h3><p>One final note for this section: the <code>AtomGraph</code> constructor broadcasts! So if you have a directory full of structure files (say, <code>strucs/</code>), you can get a list of <code>AtomGraph</code> objects by:</p><pre><code class="nohighlight hljs">ags = AtomGraph.(readdir(&quot;strucs/&quot;, join=true))</code></pre><h2 id="Building-feature-descriptors"><a class="docs-heading-anchor" href="#Building-feature-descriptors">Building feature descriptors</a><a id="Building-feature-descriptors-1"></a><a class="docs-heading-anchor-permalink" href="#Building-feature-descriptors" title="Permalink"></a></h2><p>What types of features of our structure do we want to encode in our graph? Let&#39;s keep things simple for now and consider features that can be encoded only by knowing the elemental identity of a given atom (node in our graph). The package includes a bunch of built-in data, and you can also provide your own for features we haven&#39;t included!</p><p>We can easily construct these for built-in features...</p><pre><code class="language-julia-repl hljs">julia&gt; block = ElementFeatureDescriptor(&quot;Block&quot;) # categorical feature denoting s-, p-, d-, or f-block elements
ElementFeature Block:
   categorical: true
   encoded length: 4

julia&gt; amass = ElementFeatureDescriptor(&quot;Atomic mass&quot;) # continuous-valued feature
ElementFeature Atomic mass:
   categorical: false
   encoded length: 10</code></pre><p>But suppose you have another feature that&#39;s not included. You can easily provide a lookup table (or even an entire custom encoding function!) yourself, like so...</p><pre><code class="language-julia-repl hljs">julia&gt; using DataFrames;

julia&gt; lookup_table = DataFrame([&quot;C&quot; 42; &quot;As&quot; 0], [:Symbol, :MeaningOfLife]); # make a custom lookup table for another feature

julia&gt; meaning = ElementFeatureDescriptor(&quot;MeaningOfLife&quot;, lookup_table)
ElementFeature MeaningOfLife:
   categorical: true
   encoded length: 2</code></pre><p>Note that by default, because there are a small number of possible values, ChemistryFeaturization assumes that we&#39;d like to encode this feature categorically, i.e. one &quot;bin&quot; in a one-hot vector for every possible value. Suppose we instead wanted to encode it continuously and specify a number of bins to divide the range into. We can do that like this (here I also show how to change the number of bins for continuous-valued features, which defaults to 10):</p><pre><code class="language-julia-repl hljs">julia&gt; meaning = ElementFeatureDescriptor(&quot;MeaningOfLife&quot;, lookup_table, categorical=false, nbins=3)
ElementFeature MeaningOfLife:
   categorical: false
   encoded length: 3</code></pre><h2 id="Building-a-featurization"><a class="docs-heading-anchor" href="#Building-a-featurization">Building a featurization</a><a id="Building-a-featurization-1"></a><a class="docs-heading-anchor-permalink" href="#Building-a-featurization" title="Permalink"></a></h2><p>Next, we can combine these feature descriptors into a <em>featurization object</em>, which allows convenient encoding of multiple features on a structure, and also combining of those encoded features in a manner appropriate for feeding into a model. In the case of <code>GraphNodeFeaturization</code>, we construct a column vector for each node in an <code>AtomGraph</code> by concatenating encoded features together, and then stack these vectors horizontally to form a feature matrix that we could feed into an AtomicGraphNets model.</p><p>This featurization has a convenience constructor that will build the <code>ElementFeatureDescriptor</code>s if you just pass in names of features, but with our custom lookup table feature, we will construct it by directly passing the feature descriptors:</p><pre><code class="language-julia-repl hljs">julia&gt; fzn = GraphNodeFeaturization([block, amass, meaning])
GraphNodeFeaturization encoding 3 features:
	ElementFeature Block
	ElementFeature Atomic mass
	ElementFeature MeaningOfLife</code></pre><h2 id="Featurizing-structures"><a class="docs-heading-anchor" href="#Featurizing-structures">Featurizing structures</a><a id="Featurizing-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Featurizing-structures" title="Permalink"></a></h2><p>Okay, now we&#39;re ready to encode the values of our features! Note that we can encode feature descriptors individually with two different syntax options (we&#39;ll use the same <code>triangle_C</code> graph we built above)...</p><pre><code class="language-julia-repl hljs">julia&gt; encode(block, triangle_C) # calling the encode fcn
4×3 Matrix{Float64}:
 0.0  0.0  0.0
 1.0  1.0  1.0
 0.0  0.0  0.0
 0.0  0.0  0.0

julia&gt; block(triangle_C) # object itself is callable to give value
3-element Vector{String}:
 &quot;p&quot;
 &quot;p&quot;
 &quot;p&quot;</code></pre><p>Let&#39;s encode the whole featurization!</p><pre><code class="language-julia-repl hljs">julia&gt; encode(fzn, triangle_C)
17×3 Matrix{Float64}:
 0.0  0.0  0.0
 1.0  1.0  1.0
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0
 1.0  1.0  1.0
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0
 1.0  1.0  1.0</code></pre><p>If we want to attach the encoded features to the graph, we can use the <code>featurize</code> function, which returns a <code>FeaturizedAtoms</code> object...</p><pre><code class="language-julia-repl hljs">julia&gt; featurized = featurize(triangle_C, fzn)
FeaturizedAtoms{AtomGraph{SimpleWeightedGraphs.SimpleWeightedGraph{Int64, Float32}}, GraphNodeFeaturization} with 17 x 3 encoded features:
	Atoms: AtomGraph{SimpleWeightedGraphs.SimpleWeightedGraph{Int64, Float32}}  with 3 nodes, 3 edges
	Featurization: GraphNodeFeaturization encoding 3 features</code></pre><h2 id="Decoding-encoded-features"><a class="docs-heading-anchor" href="#Decoding-encoded-features">Decoding encoded features</a><a id="Decoding-encoded-features-1"></a><a class="docs-heading-anchor-permalink" href="#Decoding-encoded-features" title="Permalink"></a></h2><p>If we have a <code>FeaturizedAtoms</code> object, we can decode it directly:</p><pre><code class="language-julia-repl hljs">julia&gt; collect(decode(featurized)) # collect as the is result is truncated in the doctest for `decode(featurized)`
3-element Vector{Pair{Integer, Dict{String, Any}}}:
 2 =&gt; Dict(&quot;MeaningOfLife&quot; =&gt; (28.0, 42.0), &quot;Block&quot; =&gt; &quot;p&quot;, &quot;Atomic mass&quot; =&gt; (9.319257777745117, 16.250547067714365))
 3 =&gt; Dict(&quot;MeaningOfLife&quot; =&gt; (28.0, 42.0), &quot;Block&quot; =&gt; &quot;p&quot;, &quot;Atomic mass&quot; =&gt; (9.319257777745117, 16.250547067714365))
 1 =&gt; Dict(&quot;MeaningOfLife&quot; =&gt; (28.0, 42.0), &quot;Block&quot; =&gt; &quot;p&quot;, &quot;Atomic mass&quot; =&gt; (9.319257777745117, 16.250547067714365))

julia&gt; typeof(decode(featurized)) # check type here, as the above doctest performs `collect` and returns a different type
Dict{Integer, Dict{String, Any}}</code></pre><p>The <code>decode</code> function also works with encoded features and a feature descriptor or featurization passed in separately.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../terminology/">« Terminology</a><a class="docs-footer-nextpage" href="../types/overview/">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 9 December 2021 17:55">Thursday 9 December 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
