var documenterSearchIndex = {"docs":
[{"location":"types/featurizations/#Featurization","page":"Featurization","title":"Featurization","text":"","category":"section"},{"location":"types/featurizations/","page":"Featurization","title":"Featurization","text":"Featurization","category":"page"},{"location":"types/featurizations/#ChemistryFeaturization.Featurization","page":"Featurization","title":"ChemistryFeaturization.Featurization","text":"Featurization\n\nA Featurization collectively stores a set of FeatureDescriptors (and any other supporting attributes that it may further require), and defines how to featurize an Atoms object by using the encoding schemes defined by the FeatureDescriptors stored.\n\n\n\n\n\n","category":"module"},{"location":"types/featurizations/","page":"Featurization","title":"Featurization","text":"Featurization defines how encoded values of different FeatureDescriptors can be collated and modified.","category":"page"},{"location":"types/featurizations/","page":"Featurization","title":"Featurization","text":"The implementation for a featurization must be as standardized and generic as possible, so that FeatureDescriptors that may be built using/use different datasets can be built and used easily.","category":"page"},{"location":"types/featurizations/","page":"Featurization","title":"Featurization","text":"GraphNodeFeaturization","category":"page"},{"location":"types/featurizations/#ChemistryFeaturization.Featurization.GraphNodeFeaturization","page":"Featurization","title":"ChemistryFeaturization.Featurization.GraphNodeFeaturization","text":"GraphNodeFeaturization(encoded_atom_features::Vector{AtomFeatureDescriptor})\nGraphNodeFeaturization(feature_names, lookup_table, nbins, logspaced, categorical)\n\nA featurization for AtomGraph objects that encodes features associated with each node. Contains a collection of AbstractAtomFeatureDescriptor objects, and can be initialized by passing those, or by passing parameters for constructing them.\n\nNotes\n\nRequired Arguments\n\nfeature_names::Vector{String}: Names of each feature\nlookup_table::DataFrame (optional): source of data for features, if not included in built-in atom_data_df\n\nKeyword Arguments\n\nnbins::Union{Vector{Integer},Integer}: Number of bins to use for one-hot encoding of continuous-valued features. Will be ignored for categorical features.\nlogspaced::Union{Vector{Bool},Bool}: Whether to logarithmically space the bins\ncategorical::Union{Vector{Bool},Bool}: Whether each feature is categorical or continous-valued.\n\n\n\n\n\n","category":"type"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We welcome community contributions! This page contains some guidance to make the process go smoothly.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Pages = [\"contributing.md\"]","category":"page"},{"location":"contributing/#General-Guidelines","page":"Contributing","title":"General Guidelines","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For some high-level general guidance, please see CONTRIBUTING.md on the GitHub repo.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The remainder of this page includes some pointers about package structure, etc. that could be helpful depending on what sorts of functionality you're interested in adding to the package. An understanding of \"what goes where\" will help in making sure you put your code in the right place! We also strongly encourage you to read the Terminology/Philosophy page, as it will help to understand the best ways to add different types of functionality.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"TODO: flesh out everything below","category":"page"},{"location":"contributing/#Implementing-new-atoms-objects","page":"Contributing","title":"Implementing new atoms objects","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"does it need to be a new type? Could it be accommodated by an existing type, or by an existing type with an expansion of functionality?\nmake sure to subtype AbstractAtoms\ncode belongs in src/atoms/, export statements belong in...\nmake sure any/all sensible FD's and fzn's dispatch on it appropriately","category":"page"},{"location":"contributing/#Implementing-new-feature-descriptors","page":"Contributing","title":"Implementing new feature descriptors","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"does it need to be a new type? Could it be accommodated by an existing type, or by an existing type with an expansion of functionality?\nmake sure to place it in the right place in the type hierarchy\ncode belongs in src/features/\nmake sure it encodes on as many atoms objects as are sensible","category":"page"},{"location":"contributing/#Implementing-new-featurization-schemes","page":"Contributing","title":"Implementing new featurization schemes","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"does it need to be a new type? Could it be accommodated by an existing type, or by an existing type with an expansion of functionality?\nshould subtype AbstractFeaturization\ncode belongs in src/featurizations/\nmake sure it encodes on as many atoms objects as are sensible","category":"page"},{"location":"custom/guide/#New-types","page":"New types","title":"New types","text":"","category":"section"},{"location":"custom/guide/","page":"New types","title":"New types","text":"A quick and nifty guide to getting started with writing new types.","category":"page"},{"location":"custom/guide/","page":"New types","title":"New types","text":"It is recommended to have custom pretty printing for types - especially Atoms, FeatureDescriptors, and Featurizations","category":"page"},{"location":"custom/guide/#Atoms-Objects","page":"New types","title":"Atoms Objects","text":"","category":"section"},{"location":"custom/guide/","page":"New types","title":"New types","text":"Always be a descendant AbstractAtoms","category":"page"},{"location":"custom/guide/#Codecs","page":"New types","title":"Codecs","text":"","category":"section"},{"location":"custom/guide/","page":"New types","title":"New types","text":"Always be a descendant AbstractCodec\ntwo fields - encode_f::Function and decode_f::Function","category":"page"},{"location":"custom/guide/","page":"New types","title":"New types","text":"Remember, a Codec is defined by the parameters the encoding/decoding scheme it is built to support takes.","category":"page"},{"location":"custom/guide/#Feature-Descriptors","page":"New types","title":"Feature Descriptors","text":"","category":"section"},{"location":"custom/guide/","page":"New types","title":"New types","text":"Always be a descendant AbstractFeatureDescriptor\nhave a field of type Codec (::AbstractCodec)\nan appropriate encodable_elements\ncallable syntax that can be dispatched generically over any AbstractAtoms object\nencode, and decode\noutput_shape\nA default Codec\nCallable syntax for the default codec, dispatched with the FeatureDescriptor type as an argument\ndefault encode-decode functions for compatible Codec(s)","category":"page"},{"location":"custom/guide/#Featurizations","page":"New types","title":"Featurizations","text":"","category":"section"},{"location":"custom/guide/","page":"New types","title":"New types","text":"Always be a descendant AbstractFeaturization\nencode and decode","category":"page"},{"location":"terminology/#Terminology/Philosophy","page":"Terminology","title":"Terminology/Philosophy","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"There are a lot of seemingly similar terms used for quantities in this package that refer to disparate things (or, are used slightly differently by other people in other places). Here, we try to best define these terms as we intend them. Further down, once the terms are defined, we elaborate on why the package is designed the way it is.","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Pages = [\"terminology.md\"]\nDepth = 3","category":"page"},{"location":"terminology/#General-Terms","page":"Terminology","title":"General Terms","text":"","category":"section"},{"location":"terminology/#Feature","page":"Terminology","title":"Feature","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"A quality or quantity associated with an atom that we wish to encode, such as atomic mass, row in the periodic table, etc.","category":"page"},{"location":"terminology/#Encoding","page":"Terminology","title":"Encoding","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"The process of translating the value of a feature from its human-readable form (such as a float or a string) to whatever form will be ingested by a machine learning model. This could be as simple as an equality operation, but more often is, e.g. building a one-hot vector.","category":"page"},{"location":"terminology/#Decoding","page":"Terminology","title":"Decoding","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"The inverse process to encoding. Note that in many cases (e.g. a continuous-valued feature encoded to a one-hot vector), the process isn't fully invertible, i.e. you can't get back a precise value but rather only a range corresponding to the associated onehot bin.","category":"page"},{"location":"terminology/#Data-types-in-ChemistryFeaturization","page":"Terminology","title":"Data types in ChemistryFeaturization","text":"","category":"section"},{"location":"terminology/#Feature-Descriptor","page":"Terminology","title":"Feature Descriptor","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Describes the \"features of a feature\" – i.e. its name, possible values, instructions for encoding it, etc., but does NOT store an actual instance of its value.","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"For more on the available types of feature descriptors, see Feature Descriptors.","category":"page"},{"location":"terminology/#AbstractCodec","page":"Terminology","title":"AbstractCodec","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Component of a feature descriptor that stores the actual encoding/decoding functions. ","category":"page"},{"location":"terminology/#Atoms-Object","page":"Terminology","title":"Atoms Object","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Describes a molecule, crystal, etc. in whatever representation will be ingested by an ML model (e.g. a graph), and can also store encoded features of that structure. ","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"For more on the available types of atoms objects, see Atoms Objects.","category":"page"},{"location":"terminology/#Featurization-Object","page":"Terminology","title":"Featurization Object","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Stores sets of feature descriptors and instructions for combining the values they encode on an atoms object.","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"For more on the available types of featurization objects, see Featurization.","category":"page"},{"location":"terminology/#Design-Philosophy","page":"Terminology","title":"Design Philosophy","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Points to elaborate on here...","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"maintaining transparency/decodability, as well as user's choice to include (or not) particular features, and choose how they are encoded, as opposed to a \"black-box\" scheme with little to no customizability\nseparation of concerns/modularity...as many things should be \"plug-and-play\" with each other as possible (e.g. swapping in different codecs to FD's, different FD's to featurizations, different featurizations to atoms objects)\nFD's and atoms objects are generic and fairly reusable across models, featurizations are less so (closer to one-to-one relationship between a featurization type and a model type, but still have flexibility to easily include/exclude different features)","category":"page"},{"location":"types/feature_descriptors/#fd","page":"Feature Descriptors","title":"Feature Descriptors","text":"","category":"section"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"FeatureDescriptor","category":"page"},{"location":"types/feature_descriptors/#ChemistryFeaturization.FeatureDescriptor","page":"Feature Descriptors","title":"ChemistryFeaturization.FeatureDescriptor","text":"FeatureDescriptor\n\nA feature, in this context, refers to a distinct attribute manifested by an atomic system. A FeatureDescriptor describes a feature/class of features - i.e., its name, possible values, etc.\n\nA FeatureDescriptor does NOT store any actual instances of the value(s) of the feature it describes. Simply put, it can be understood to be \"features of a feature\".\n\nAll FeatureDescriptors MUST also describe an encoding and decoding scheme. This can (and should) be easily done using a Codec.\n\n\n\n\n\n","category":"module"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"Feature descriptors store all necessary information to encode and decode feature values on various parts of an atoms object and appropriately combine them into a single object (vector, matrix, etc.) describing the value/values of the feature for the entire object.","category":"page"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"For example, if an ElementFeatureDescriptor encodes a vector for each atom in an object, they could be concatenated together into a matrix with a column for each atom to describe a structure.","category":"page"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"Feature Descriptors must be designed with interoperability in mind. A FeatureDescriptor object must work deterministically with different datasets.","category":"page"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"The type hierarchy of these objects is currently:","category":"page"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"|---- AbstractFeatureDescriptor\n    |---- AbstractAtomFeatureDescriptor\n        |==== ElementFeatureDescriptor\n        |==== SpeciesFeatureDescriptor\n    |---- AbstractPairFeatureDescriptor\n        |==== PairFeatureDescriptor\n        |---- BondFeatureDescriptor\n            |==== BondType\n            |==== InRing\n            |==== IsConjugated","category":"page"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"where  ---- = Abstract Type and ==== = Concrete Type","category":"page"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"More details on each of these types is below, and more types (e.g. environment features) will be implemented in the future!","category":"page"},{"location":"types/feature_descriptors/#Functionality-common-to-all-feature-descriptors","page":"Feature Descriptors","title":"Functionality common to all feature descriptors","text":"","category":"section"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"they should be callable on atoms objects and return encoded features\nSimilarly, decode should work...","category":"page"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"decode(::FeatureDescriptor.AbstractFeatureDescriptor, ::Any)","category":"page"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"the function encodable_elements should be defined on all feature descriptors, as it will be used to verify that a feature can be encoded for every atom in a structure.","category":"page"},{"location":"types/feature_descriptors/#Atom-Feature-Descriptors","page":"Feature Descriptors","title":"Atom Feature Descriptors","text":"","category":"section"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"These types encode features for single atoms in a structure. The abstract parent type is AtomFeatureDescriptor.","category":"page"},{"location":"types/feature_descriptors/#Element-Feature-Descriptors","page":"Feature Descriptors","title":"Element Feature Descriptors","text":"","category":"section"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"An ElementFeatureDescriptor's encoded values are defined only by the elemental identity of an atom. Examples include atomic mass and block (s, p, d, or f) in the periodic table.","category":"page"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"ElementFeatureDescriptor","category":"page"},{"location":"types/feature_descriptors/#ChemistryFeaturization.FeatureDescriptor.ElementFeatureDescriptor","page":"Feature Descriptors","title":"ChemistryFeaturization.FeatureDescriptor.ElementFeatureDescriptor","text":"ElementFeatureDescriptor\n\nDescribe features associated with individual atoms that depend only upon their elemental identity\n\nFields\n\nname::String: Name of the feature\nencoder_decoder::AbstractCodec: Codec defined which handles the feature's encoding and decoding logic\ncategorical::Bool: flag for whether the feature is categorical or continuous-valued\nlookup_table::DataFrame: table containing values of feature for every encodable element\n\n\n\n\n\n","category":"type"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"In the example, below, we encode the block of each atom in a hydrogen molecule. The result is two hcatted vectors [1 0 0 0], indicating hydrogen is s-block.","category":"page"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"H2 = AtomGraph([0. 1.; 1. 0.], [\"H\", \"H\"])\nblock = ElementFeatureDescriptor(\"Block\")\nblock(H2)\n\n# output\n4×2 Matrix{Float64}:\n 1.0  1.0\n 0.0  0.0\n 0.0  0.0\n 0.0  0.0","category":"page"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"Because they are defined only by the element, values for these features can be tabulated in a lookup table. Many commonly-desired element features are included in the atom_data_df DataFrame, but you can also define custom lookup tables for other features by utilizing the lookup_table keyword of the ElementFeatureDescriptor constructor.","category":"page"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"TODO: add remark about encoding options once that PR is merged","category":"page"},{"location":"types/feature_descriptors/#Species-Feature-Descriptor","page":"Feature Descriptors","title":"Species Feature Descriptor","text":"","category":"section"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"A SpeciesFeatureDescriptor's encoded values depend on its local environment. Examples are an atom's format oxidation state, or whether it is part of an aromatic ring.","category":"page"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"FeatureDescriptor.SpeciesFeatureDescriptor","category":"page"},{"location":"types/feature_descriptors/#ChemistryFeaturization.FeatureDescriptor.SpeciesFeatureDescriptor","page":"Feature Descriptors","title":"ChemistryFeaturization.FeatureDescriptor.SpeciesFeatureDescriptor","text":"SpeciesFeatureDescriptor(feature_name, encode_f, decode_f, categorical, contextual, length, encodable_elements)\n\nConstruct a feature object that encodes features associated with individual atoms that depend upon their local environment in some way (if your feature is defined only by elemental identity, you should use ElementFeatureDescriptor!)\n\nArguments\n\nname::String: the name of the feature\nencode_f::Function: a function that takes in <:AbstractAtoms and returns encoded values of this feature for the atoms in that structure\ndecode_f::Function: inverse function to encode_f, takes in encoded feature and returns value (for categorical) or range of values (for continuous-valued) of the feature\ncategorical::Bool: flag for whether the feature is categorical or continuous-valued\nlength::Int: length of encoded vector\nencodable_elements::Vector{String}: list of elements (by symbol) that can be encoded by this feature\n\n\n\n\n\n","category":"type"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"TODO: more details once we have better examples","category":"page"},{"location":"types/feature_descriptors/#Pair-Feature-Descriptors","page":"Feature Descriptors","title":"Pair Feature Descriptors","text":"","category":"section"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"Pair feature descriptors encode features of pairs of atoms. The abstract parent type is AbstractPairFeatureDescriptor.","category":"page"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"The concrete type PairFeatureDescriptor encodes information about any pair of atoms, such as the distance between them.","category":"page"},{"location":"types/feature_descriptors/#Bond-Feature-Descriptors","page":"Feature Descriptors","title":"Bond Feature Descriptors","text":"","category":"section"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"Bond feature descriptors are defined only for two atoms that are bonded to each other.","category":"page"},{"location":"types/feature_descriptors/","page":"Feature Descriptors","title":"Feature Descriptors","text":"TODO: more details here","category":"page"},{"location":"types/atoms/#atoms","page":"Atoms Objects","title":"Atoms Objects","text":"","category":"section"},{"location":"types/atoms/","page":"Atoms Objects","title":"Atoms Objects","text":"Atoms","category":"page"},{"location":"types/atoms/#ChemistryFeaturization.Atoms","page":"Atoms Objects","title":"ChemistryFeaturization.Atoms","text":"Atoms\n\nAtoms objects characterize structural representations of molecular structures. These representations can either be standardized forms (like graph representation using an adjacency matrix, point cloud representation, etc), or be custom user-defined representations too.\n\n\n\n\n\n","category":"module"},{"location":"types/atoms/","page":"Atoms Objects","title":"Atoms Objects","text":"Atoms objects (terminology borrowed from ASE) store information about the structure of a molecule, crystal, etc. as well as, optionally, encoded features and the featurization used to encode them. The parent abstract type is AbstractAtoms.","category":"page"},{"location":"types/atoms/#AtomGraph","page":"Atoms Objects","title":"AtomGraph","text":"","category":"section"},{"location":"types/atoms/","page":"Atoms Objects","title":"Atoms Objects","text":"The AtomGraph type is used to store atomic graph representations. It can also be visualized using some customized formatting with the GraphPlot package.","category":"page"},{"location":"types/atoms/","page":"Atoms Objects","title":"Atoms Objects","text":"Atoms.AtomGraph\nAtoms.AtomGraph(::String, ::String)\nAtoms.visualize","category":"page"},{"location":"types/atoms/#ChemistryFeaturization.Atoms.AtomGraph","page":"Atoms Objects","title":"ChemistryFeaturization.Atoms.AtomGraph","text":"AtomGraph\n\nA type representing an atomic structure as a graph (gr).\n\nFields\n\ngraph::SimpleWeightedGraph{<:Integer,<:Real}: the graph representing the structure. See build_graph for more on generating the weights.\nelements::Vector{String}: list of elemental symbols corresponding to each node of the graph\nlaplacian::Matrix{<:Real}: Normalized graph Laplacian matrix, stored to speed up convolution operations by avoiding recomputing it every pass.\nid::String: Optional, an identifier, e.g. to correspond with tags/labels of an imported dataset.\n\n\n\n\n\n","category":"type"},{"location":"types/atoms/#ChemistryFeaturization.Atoms.AtomGraph-Tuple{String,String}","page":"Atoms Objects","title":"ChemistryFeaturization.Atoms.AtomGraph","text":"AtomGraph(input_file_path, id = splitext(input_file_path)[begin]; output_file_path = nothing, featurization = nothing, overwrite_file = false, use_voronoi = false, cutoff_radius = 8.0, max_num_nbr = 12, dist_decay_func = inverse_square, normalize_weights = true)\n\nConstruct an AtomGraph object from a structure file.\n\nRequired Arguments\n\ninput_file_path::String: path to file containing structure (must be readable by ASE.io.read)\n\nOptional Arguments\n\nid::String: ID associated with structure (e.g. identifier from online database). Defaults to name of input file if undefined.\noutput_file_path = nothing: If provided, structure will be serialized to file at this location\noverwrite_file::Bool = false: whether to overwrite an existing file at output_file_path\nuse_voronoi::Bool = false: Whether to build neighbor lists using Voronoi decompositions\ncutoff_radius::Real = 8.0: If not using Voronoi neighbor lists, longest allowable distance to a neighbor, in Angstroms\nmax_num_nbr::Integer = 12: If not using Voronoi neighbor lists, largest allowable number of neighbors\ndist_decay_func = inverse_square: Function by which to assign edge weights according to distance between neighbors\nnormalize_weights::Bool = true: Whether to normalize weights such that the largest is 1.0\n\nNote\n\nmax_num_nbr is a \"soft\" limit – if multiple neighbors are at the same distance, the full neighbor list may be longer.\n\n\n\n\n\n","category":"method"},{"location":"types/atoms/#ChemistryFeaturization.Atoms.visualize","page":"Atoms Objects","title":"ChemistryFeaturization.Atoms.visualize","text":"Visualize a given graph.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Some helper/utility functions that aren't documented elsewhere...","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Pages = [\"utils.md\"]","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Modules = [Utils.ElementFeatureUtils, Utils.GraphBuilding]","category":"page"},{"location":"utils/#ChemistryFeaturization.Utils.ElementFeatureUtils.default_categorical","page":"Utilities","title":"ChemistryFeaturization.Utils.ElementFeatureUtils.default_categorical","text":"default_categorical(feature_name, lookup_table = atom_data_df)\n\nDetermine if a feature should be treated as categorical or continuous-valued.\n\nIf the value type is not a number, always returns true. If it is, checks whether it is in the built-in list of categorical features.\n\nTODO: possibly add behavior where it will default to categorical if there is below some threshold number of discrete values?\n\n\n\n\n\n","category":"function"},{"location":"utils/#ChemistryFeaturization.Utils.ElementFeatureUtils.default_log","page":"Utilities","title":"ChemistryFeaturization.Utils.ElementFeatureUtils.default_log","text":"default_log(feature_name, lookup_table = atom_data_df; threshold = oom_threshold_log)\n\nDetermine whether a continuous-valued feature should have logarithmically spaced bins. \n\nOperates by finding the minimum and maximum values the feature can take on and comparing their ratio to a specified order-of-magnitude threshold that defaults to a package constant if not provided.\n\n\n\n\n\n","category":"function"},{"location":"utils/#ChemistryFeaturization.Utils.ElementFeatureUtils.fea_minmax","page":"Utilities","title":"ChemistryFeaturization.Utils.ElementFeatureUtils.fea_minmax","text":"Compute the minimum and maximum possible values of a feature.\n\n\n\n\n\n","category":"function"},{"location":"utils/#ChemistryFeaturization.Utils.ElementFeatureUtils.get_bins","page":"Utilities","title":"ChemistryFeaturization.Utils.ElementFeatureUtils.get_bins","text":"Helper function for encoder and decoder...(nbins is ignored for categorical=true)\n\n\n\n\n\n","category":"function"},{"location":"utils/#ChemistryFeaturization.Utils.ElementFeatureUtils.get_param_vec-Tuple{Any,Integer}","page":"Utilities","title":"ChemistryFeaturization.Utils.ElementFeatureUtils.get_param_vec","text":"Little helper function to check that the logspace/categorical vector/boolean is appropriate and convert it to a vector as needed.\n\n\n\n\n\n","category":"method"},{"location":"utils/#ChemistryFeaturization.Utils.ElementFeatureUtils.onecold_decoder","page":"Utilities","title":"ChemistryFeaturization.Utils.ElementFeatureUtils.onecold_decoder","text":"Function for decoding onehot-style vectors based on values in a lookup table. Intended to be used as an decode_f for ElementFeatureDescriptor objects. See source code of convenience constructor for ElementFeatureDescriptor for more details.\n\n\n\n\n\n","category":"function"},{"location":"utils/#ChemistryFeaturization.Utils.ElementFeatureUtils.onehot_lookup_encoder","page":"Utilities","title":"ChemistryFeaturization.Utils.ElementFeatureUtils.onehot_lookup_encoder","text":"Function for encoding onehot-style vectors based on values in a lookup table. Intended to be used as an encode_f for ElementFeatureDescriptor objects. See source code of convenience constructor for ElementFeatureDescriptor for more details.\n\n\n\n\n\n","category":"function"},{"location":"utils/#ChemistryFeaturization.Utils.GraphBuilding.build_graph-Tuple{String}","page":"Utilities","title":"ChemistryFeaturization.Utils.GraphBuilding.build_graph","text":"Function to build graph from a file storing a crystal structure (currently supports anything ase.io.read can read in). Returns an AtomGraph object.\n\nArguments\n\nRequired Arguments\n\nfile_path::String: Path to ASE-readable file containing a molecule/crystal structure\n\nKeyword Arguments\n\nnormalize_weights::Bool=true: Whether to rescale graph weights such that the maximum value is 1.0 (recommended)\nuse_voronoi::bool: if true, use Voronoi method for neighbor lists, if false use cutoff method\n(The rest of these parameters are only used if use_voronoi==false)\ncutoff_radius::Real=8.0: cutoff radius for atoms to be considered neighbors (in angstroms)\nmax_num_nbr::Integer=12: maximum number of neighbors to include (even if more fall within cutoff radius)\ndist_decay_func::Function=inverse_square: function to determine falloff of graph edge weights with neighbor distance\n\n\n\n\n\n","category":"method"},{"location":"utils/#ChemistryFeaturization.Utils.GraphBuilding.weights_cutoff-Tuple{Any,Any,Any}","page":"Utilities","title":"ChemistryFeaturization.Utils.GraphBuilding.weights_cutoff","text":"Build graph using neighbor number cutoff method adapted from original CGCNN. Note that max_num_nbr is a \"soft\" max, in that if there are more of the same distance as the last, all of those will be added.\n\n\n\n\n\n","category":"method"},{"location":"utils/#ChemistryFeaturization.Utils.GraphBuilding.weights_voronoi-Tuple{Any}","page":"Utilities","title":"ChemistryFeaturization.Utils.GraphBuilding.weights_voronoi","text":"Build graph using neighbors from faces of Voronoi polyedra and weights from areas. Based on the approach from https://github.com/ulissigroup/uncertaintybenchmarking/blob/aabb407807e35b5fd6ad06b14b440609ae09e6ef/BNN/datapyro.py#L268\n\n\n\n\n\n","category":"method"},{"location":"types/abstracttypes/#Abstract-Types","page":"Abstract Types","title":"Abstract Types","text":"","category":"section"},{"location":"types/abstracttypes/","page":"Abstract Types","title":"Abstract Types","text":"Modules = [AbstractType]","category":"page"},{"location":"types/abstracttypes/#ChemistryFeaturization.AbstractType.AbstractAtoms","page":"Abstract Types","title":"ChemistryFeaturization.AbstractType.AbstractAtoms","text":"AbstractAtoms\n\nAll types defined for different representations of atomic systems (different Atoms types) must be a subtype of AbstractAtoms.\n\n\n\n\n\n","category":"type"},{"location":"types/abstracttypes/#ChemistryFeaturization.AbstractType.AbstractCodec","page":"Abstract Types","title":"ChemistryFeaturization.AbstractType.AbstractCodec","text":"AbstractCodec\n\nAll codecs defined for different encoding-decoding schemes must be a subtype of AbstractCodec.\n\n\n\n\n\n","category":"type"},{"location":"types/abstracttypes/#ChemistryFeaturization.AbstractType.AbstractFeatureDescriptor","page":"Abstract Types","title":"ChemistryFeaturization.AbstractType.AbstractFeatureDescriptor","text":"AbstractFeatureDescriptor\n\nAll FeatureDescriptors defined for different types of features must be a subtype of AbstractFeatureDescriptor.\n\n\n\n\n\n","category":"type"},{"location":"types/abstracttypes/#ChemistryFeaturization.AbstractType.AbstractFeaturization","page":"Abstract Types","title":"ChemistryFeaturization.AbstractType.AbstractFeaturization","text":"AbstractFeaturization\n\nAll types defined for different featurizations must be a subtype of AbstractFeaturization.\n\n\n\n\n\n","category":"type"},{"location":"changelog/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"I'm generally trying to adhere to semver here. This means that in v0.*, assume breaking changes are always possible, even without a major version bump...however, I will try to always note them here if they happen...","category":"page"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Categories to include for each release, if relevant: breaking, added, fixed, removed/deprecated","category":"page"},{"location":"changelog/#Upcoming","page":"Changelog","title":"Upcoming","text":"","category":"section"},{"location":"changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"add pretty printing for GraphNodeFeaturization, FeaturizedAtoms, uniformize spacing via \\t across these and AtomGraph\n[logic] move data/ directory to root of repo\n[logic] move build_onehot_vec to OneHotOneCold","category":"page"},{"location":"changelog/#Fixed","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"export featurize and decode properly for FeaturizedAtoms","category":"page"},{"location":"changelog/#v0.4.2-[2021-07-02]","page":"Changelog","title":"v0.4.2 [2021-07-02]","text":"","category":"section"},{"location":"changelog/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"export featurize and decode functions at top-level module","category":"page"},{"location":"changelog/#Fixed-2","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"id is positional rather than keyword argument in AtomGraph constructor so that broadcast works properly, also it defaults to filename sans extension when constructing from file","category":"page"},{"location":"changelog/#v0.4.1-[2021-07-01]","page":"Changelog","title":"v0.4.1 [2021-07-01]","text":"","category":"section"},{"location":"changelog/#Fixed-3","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"add back wayward semicolon so that keyword arguments work in AtomGraph constructor from file","category":"page"},{"location":"changelog/#v0.4.0-[2021-06-30]","page":"Changelog","title":"v0.4.0 [2021-06-30]","text":"","category":"section"},{"location":"changelog/#Added-3","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"create FeaturizedAtoms type, remove featurization, encoded_features fields from Atoms objects\nadd docstrings for various things, add section of docs for Codecs","category":"page"},{"location":"changelog/#Fixed-4","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"macOS CI fixed, but possibly not in an ideal way because it seems to result in occasional precompile warnings upon update\nDocs for stable/tagged versions now build properly","category":"page"},{"location":"changelog/#Removed/Deprecated","page":"Changelog","title":"Removed/Deprecated","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"remove encoded features field from AtomGraph type","category":"page"},{"location":"changelog/#v0.3.1-[2021-06-18]","page":"Changelog","title":"v0.3.1 [2021-06-18]","text":"","category":"section"},{"location":"changelog/#Fixed-5","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"import from submodules before top-level export so that exports actually work, d'oh\nremove broken dimension check in AtomGraph constructor (doesn't work with generic featurization)\nfix type assertion of nbins in GraphNodeFeaturization constructor (Vector{<:Integer}, NOT Vector{Integer})","category":"page"},{"location":"changelog/#v0.3.0-[2021-06-17]","page":"Changelog","title":"v0.3.0 [2021-06-17]","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Major restructure to make extensibility far easier and allow better sharing of elements between featurization schemes! Also streamlined the codebase a lot by organizing things into sensible modules, so technically basically everything is a breaking change because all of the imports are from the submodules now.","category":"page"},{"location":"changelog/#Breaking/Added","page":"Changelog","title":"Breaking/Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"create modules for different functionalities: Atoms, Features, Featurization, Utils, etc.\nseparate out encoding/decoding functionality into a new AbstractCodec type and associated Codec module\nmerged functionality of AtomGraph and WeaveMol into AtomGraph object, with a more generic encoded_features field","category":"page"},{"location":"changelog/#v0.2.2-[2021-02-22]","page":"Changelog","title":"v0.2.2 [2021-02-22]","text":"","category":"section"},{"location":"changelog/#Added-4","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"updated pretty printing for AtomGraph to include id field","category":"page"},{"location":"changelog/#Fixed-6","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"added some docstrings, updated others","category":"page"},{"location":"changelog/#v0.2.1-[2021-02-22]","page":"Changelog","title":"v0.2.1 [2021-02-22]","text":"","category":"section"},{"location":"changelog/#Breaking","page":"Changelog","title":"Breaking","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"rename build_atom_feats to build_featurization to avoid ambiguity with make_feature_vectors","category":"page"},{"location":"changelog/#Fixed-7","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"proper docstrings for more things incl. AtomFeat, AtomGraph, add_features!","category":"page"},{"location":"changelog/#v0.2.0-[2021-02-16]","page":"Changelog","title":"v0.2.0 [2021-02-16]","text":"","category":"section"},{"location":"changelog/#Breaking-2","page":"Changelog","title":"Breaking","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"add id field to AtomGraph (should only be breaking for reading in serialized graphs)\nbuild_graphs_batch now returns list of graphs and optionally serializes rather than always serializing and never returning","category":"page"},{"location":"changelog/#Added-5","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"add_features_batch! function\nAtomGraph constructor directly from adjacency matrix (previously was only from a SimpleWeightedGraph)","category":"page"},{"location":"changelog/#Fixed-8","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"remove deprecated syntax of opening DataFrames from CSV\nmade separate files into modules to avoid redefinition warnings during precompilation","category":"page"},{"location":"changelog/#v0.1.1-[2021-02-10]","page":"Changelog","title":"v0.1.1 [2021-02-10]","text":"","category":"section"},{"location":"changelog/#Fixed-9","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"add check for NaN values in graph laplacian","category":"page"},{"location":"changelog/#v0.1.0-[2020-12-22]","page":"Changelog","title":"v0.1.0 [2020-12-22]","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Initial release!","category":"page"},{"location":"changelog/#Added-6","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Create AtomGraph and AtomFeat types\nBasic graph visualization functions\nGraph-building from CIF files via the cgcnn.py \"cutoff\" method, with support for nonperiodic systems as well","category":"page"},{"location":"types/featurizedatoms/#Featurized-Atoms","page":"Featurized Atoms","title":"Featurized Atoms","text":"","category":"section"},{"location":"types/featurizedatoms/","page":"Featurized Atoms","title":"Featurized Atoms","text":"A FeaturizedAtoms object is a flexible container for an Atoms object, a compatible Featurization object, and the resulting encoded features. The type is parameterized by the type of atoms object and the featurization type, e.g. FeaturizedAtoms{AtomGraph,GraphNodeFeaturization}.","category":"page"},{"location":"types/featurizedatoms/","page":"Featurized Atoms","title":"Featurized Atoms","text":"This is intended to be the type that is directly fed into a Chemellia model, so the format of encoded_features should be whatever the associated model requires, and not necessarily human-readable (though interpretable through the decode function!).","category":"page"},{"location":"types/featurizedatoms/","page":"Featurized Atoms","title":"Featurized Atoms","text":"FeaturizedAtoms","category":"page"},{"location":"types/featurizedatoms/#ChemistryFeaturization.FeaturizedAtoms","page":"Featurized Atoms","title":"ChemistryFeaturization.FeaturizedAtoms","text":"FeaturizedAtoms\n\nContainer object for an Atoms object, a featurization, and the resulting encoded_features from applying the featurization to the atoms.\n\nNote: encoded_features will NOT change for a given atoms-featurization pair.\n\n\n\n\n\n","category":"type"},{"location":"types/codecs/#Codecs","page":"Codec","title":"Codecs","text":"","category":"section"},{"location":"types/codecs/","page":"Codec","title":"Codec","text":"Codec\nCodec.OneHotOneCold","category":"page"},{"location":"types/codecs/#ChemistryFeaturization.Codec","page":"Codec","title":"ChemistryFeaturization.Codec","text":"Codec\n\nCodecs provide the encoding-decoding scheme in a flexible way. Codecs are titled according to the general attributes that the codec scheme would require, and NOT the actual encoding/decoding function itself.\n\nEvery Codec object MUST have one set of encode_f::Function and decode_f::Function fields.\n\nThis makes things customizable, and allows plug-and-play behaviour with different variants of the same codec scheme, or for strikingly similar codec schemes.\n\n\n\n\n\n","category":"module"},{"location":"types/codecs/#ChemistryFeaturization.Codec.OneHotOneCold","page":"Codec","title":"ChemistryFeaturization.Codec.OneHotOneCold","text":"OneHotOneCold(encode_f, decode_f, nbins, logspaced)\n\nAbstractCodec type which uses a dummy variable (as defined in statistical literature), i.e., which employs one-hot encoding and a one-cold decoding scheme.\n\n\n\n\n\n","category":"type"},{"location":"#ChemistryFeaturization.jl","page":"Home","title":"ChemistryFeaturization.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Data types and featurization schemes for Chemellia models and beyooond!","category":"page"},{"location":"","page":"Home","title":"Home","text":"ChemistryFeaturization.jl is meant to be a unified interface for translating atomic structures (molecules, crystals, etc.) into data structures and sets of features to be used in machine learning models provided by the Alchemy suite of packages, such as AtomicGraphNets.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is in development as part of the ACED project, funded by ARPA-E DIFFERENTIATE and coordinated by a team from Carnegie Mellon University, in collaboration with Julia Computing, Citrine Informatics, and MIT. Dr. Rachel Kurchin is the lead developer.","category":"page"},{"location":"#Purpose","page":"Home","title":"Purpose","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is intended to serve as a \"helper package\" of sorts for other packages that actually build the models, and NOT as a standalone tool (for instance, ChemistryFeaturization.jl it does not itself implement any models).","category":"page"},{"location":"","page":"Home","title":"Home","text":"It provides flexible, modular data types and functions for starting from a \"bare\" atomic structure of a molecule or crystal, featurizing it with various tabulated or computed properties of its constituent atoms, bonds, etc., and encoding those features into a format appropriate to ingest into a machine learning model. Critically, it also provides functions for inverting this process, i.e. decoding the featurization, as all necessary metadata is retained.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: CF_flowchart)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To learn more about the package, it would be good to start with the Terminology/Philosophy section to get a handle on the vocabulary as we use it, and also some insights about the design philosophy behind the package. Then go ahead and browse the sidebar for more!","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pages = [\"tutorial.md\"]\nDepth = 3","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nThis tutorial is currently focused on AtomGraph objects, featurized using ElementFeatureDescriptors in a GraphNodeFeaturization, because these are the functionalities that are currently fully built, but we anticipate expanding it as more things are finished!","category":"page"},{"location":"tutorial/#Creating/reading-in-a-structure","page":"Tutorial","title":"Creating/reading in a structure","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DocTestSetup = quote\n    using ChemistryFeaturization\nend","category":"page"},{"location":"tutorial/#Create-\"from-scratch\"","page":"Tutorial","title":"Create \"from scratch\"","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can build an AtomGraph \"manually,\" by specifying an adjacency matrix and directly building the graph from that. Here I'll build a fictitious graph that's just an equiweighted triangle of carbon atoms:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> adj_mat = Float32.([0 1 1; 1 0 1; 1 1 0]);\n\njulia> triangle_C = AtomGraph(adj_mat, [\"C\", \"C\", \"C\"])\nAtomGraph  with 3 nodes, 3 edges\n\tatoms: [\"C\", \"C\", \"C\"]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you're working in an IDE that supports graphics output, you can also call visualize(triangle_C) to see the \"ball-and-stick\" graph.","category":"page"},{"location":"tutorial/#Reading-from-file","page":"Tutorial","title":"Reading from file","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In a \"real\" application, you'll likely be reading structures from files such as .cif, .xyz, etc. Here, we'll read in the structure of WS<sub>2</sub>, downloaded from the Materials Project:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> WS2 = AtomGraph(\"mp-224.cif\")\nAtomGraph mp-224 with 6 nodes, 9 edges\n\tatoms: [\"W\", \"W\", \"S\", \"S\", \"S\", \"S\"]\n","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The graph is automatically assigned an id based on the filename it was read from, but you can pass a value to override this and name it something else.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you visualize this graph as above, you'll notice that it has two disconnected components. This isn't too surprising if we look at the 3D structure of this compound: (Image: WS2_structure) It's a two-dimensional material with two formula units per unit cell! Another way to see the disconnectedness of the graph is to index into the adjacency matrix in a particularly illustrative order:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> WS2.graph[[1,4,6,2,3,5]].weights\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 18 stored entries:\n 1.0     0.9732   0.9732    ⋅       ⋅        ⋅ \n 0.9732  1.0      0.17143   ⋅       ⋅        ⋅ \n 0.9732  0.17143  1.0       ⋅       ⋅        ⋅ \n  ⋅       ⋅        ⋅       1.0     0.9732   0.9732\n  ⋅       ⋅        ⋅       0.9732  1.0      0.17143\n  ⋅       ⋅        ⋅       0.9732  0.17143  1.0\n","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"However, we have options in how we actually construct the graph. The default option is based on the scheme from the original cgcnn.py implementation, which essentially involves setting a maximum neighbor distance and a maximum number of neighbors. However, in contrast to that implementation, we construct weighted graphs (with the user having an ability to specify the weight decay function with separation distance; it defaults to inverse-square).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"An arguably more physical way to construct neighbor lists and graphs is by doing a Voronoi partition of the atomic coordinates. In this scheme, the neighbor list of an atom is any atom with which its Voronoi polyhedron shares a face, and the edge weights can be determined using the areas of the faces. Let's try that with our WS<sub>2</sub> structure...","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> WS2_v = AtomGraph(joinpath(\"..\", \"files\", \"mp-224.cif\"), use_voronoi=true);\n\njulia> WS2_v.graph[[1,4,6,2,3,5]].weights\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 22 stored entries:\n 0.371678  0.970447   0.970447    ⋅         ⋅          ⋅ \n 0.970447  1.0        0.0231855   ⋅         ⋅         0.31894\n 0.970447  0.0231855  1.0         ⋅        0.31894     ⋅ \n  ⋅         ⋅          ⋅         0.371678  0.970447   0.970447\n  ⋅         ⋅         0.31894    0.970447  1.0        0.0231855\n  ⋅        0.31894     ⋅         0.970447  0.0231855  1.0","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(You can, of course, also visualize this one in your IDE)","category":"page"},{"location":"tutorial/#Batch-processing","page":"Tutorial","title":"Batch processing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One final note for this section: the AtomGraph constructor broadcasts! So if you have a directory full of structure files (say, strucs/), you can get a list of AtomGraph objects by:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ags = AtomGraph.(readdir(\"strucs/\", join=true))","category":"page"},{"location":"tutorial/#Building-feature-descriptors","page":"Tutorial","title":"Building feature descriptors","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"What types of features of our structure do we want to encode in our graph? Let's keep things simple for now and consider features that can be encoded only by knowing the elemental identity of a given atom (node in our graph). The package includes a bunch of built-in data, and you can also provide your own for features we haven't included!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can easily construct these for built-in features...","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> block = ElementFeatureDescriptor(\"Block\") # categorical feature denoting s-, p-, d-, or f-block elements\nElementFeature Block:\n   categorical: true\n   encoded length: 4\n\njulia> amass = ElementFeatureDescriptor(\"Atomic mass\") # continuous-valued feature\nElementFeature Atomic mass:\n   categorical: false\n   encoded length: 10","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"But suppose you have another feature that's not included. You can easily provide a lookup table (or even an entire custom encoding function!) yourself, like so...","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using DataFrames;\n\njulia> lookup_table = DataFrame([\"C\" 42; \"As\" 0], [:Symbol, :MeaningOfLife]); # make a custom lookup table for another feature\n\njulia> meaning = ElementFeatureDescriptor(\"MeaningOfLife\", lookup_table)\nElementFeature MeaningOfLife:\n   categorical: true\n   encoded length: 2","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that by default, because there are a small number of possible values, ChemistryFeaturization assumes that we'd like to encode this feature categorically, i.e. one \"bin\" in a one-hot vector for every possible value. Suppose we instead wanted to encode it continuously and specify a number of bins to divide the range into. We can do that like this (here I also show how to change the number of bins for continuous-valued features, which defaults to 10):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> meaning = ElementFeatureDescriptor(\"MeaningOfLife\", lookup_table, categorical=false, nbins=3)\nElementFeature MeaningOfLife:\n   categorical: false\n   encoded length: 3","category":"page"},{"location":"tutorial/#Building-a-featurization","page":"Tutorial","title":"Building a featurization","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we can combine these feature descriptors into a featurization object, which allows convenient encoding of multiple features on a structure, and also combining of those encoded features in a manner appropriate for feeding into a model. In the case of GraphNodeFeaturization, we construct a column vector for each node in an AtomGraph by concatenating encoded features together, and then stack these vectors horizontally to form a feature matrix that we could feed into an AtomicGraphNets model.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This featurization has a convenience constructor that will build the ElementFeatureDescriptors if you just pass in names of features, but with our custom lookup table feature, we will construct it by directly passing the feature descriptors:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> fzn = GraphNodeFeaturization([block, amass, meaning])\nGraphNodeFeaturization encoding 3 features:\n\tElementFeature Block\n\tElementFeature Atomic mass\n\tElementFeature MeaningOfLife","category":"page"},{"location":"tutorial/#Featurizing-structures","page":"Tutorial","title":"Featurizing structures","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Okay, now we're ready to encode the values of our features! Note that we can encode feature descriptors individually with two different syntax options (we'll use the same triangle_C graph we built above)...","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> encode(block, triangle_C) # calling the encode fcn\n4×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 1.0  1.0  1.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia> block(triangle_C) # object itself is callable\n4×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 1.0  1.0  1.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's encode the whole featurization!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> encode(fzn, triangle_C)\n17×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 1.0  1.0  1.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 1.0  1.0  1.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 1.0  1.0  1.0","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If we want to attach the encoded features to the graph, we can use the featurize function, which returns a FeaturizedAtoms object...","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> featurized = featurize(triangle_C, fzn)\nFeaturizedAtoms{AtomGraph, GraphNodeFeaturization} with 17 x 3 encoded features:\n\tAtoms: AtomGraph  with 3 nodes, 3 edges\n\tFeaturization: GraphNodeFeaturization encoding 3 features","category":"page"},{"location":"tutorial/#Decoding-encoded-features","page":"Tutorial","title":"Decoding encoded features","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If we have a FeaturizedAtoms object, we can decode it directly:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> collect(decode(featurized)) # collect as the is result is truncated in the doctest for `decode(featurized)`\n3-element Vector{Pair{Integer, Dict{String, Any}}}:\n 2 => Dict(\"MeaningOfLife\" => (28.0, 42.0), \"Block\" => \"p\", \"Atomic mass\" => (9.319257777745117, 16.250547067714365))\n 3 => Dict(\"MeaningOfLife\" => (28.0, 42.0), \"Block\" => \"p\", \"Atomic mass\" => (9.319257777745117, 16.250547067714365))\n 1 => Dict(\"MeaningOfLife\" => (28.0, 42.0), \"Block\" => \"p\", \"Atomic mass\" => (9.319257777745117, 16.250547067714365))\n\njulia> typeof(decode(featurized)) # check type here, as the above doctest performs `collect` and returns a different type\nDict{Integer, Dict{String, Any}}","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The decode function also works with encoded features and a feature descriptor or featurization passed in separately.","category":"page"}]
}
